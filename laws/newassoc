
associativity = par a (par b c) == fmap assoc (par (par a b) c)

goesFirst a (par b c) ~+~ fmap swap (goesFirst (par b c) a) == fmap assoc (goesFirst (par a b) c ~+~ fmap swap (goesFirst c (par a b)))
goesFirst a (par b c) ~+~ fmap swap (goesFirst (goesFirst b c ~+~ fmap swap (goesFirst c b)) a) == fmap assoc (goesFirst (goesFirst a b ~+~ fmap swap (goesFirst b a)) c ~+~ fmap swap (goesFirst c (par a b)))

distribute
goesFirst a (par b c) ~+~ fmap swap (goesFirst (goesFirst b c) a) ~+~ fmap swap (goestFirst (fmap swap (goesFirst c b)) a) == fmap assoc (goesFirst (goesFirst a b) c ~+~ goesFirst (fmap swap (goesFirst b a)) c ~+~ fmap swap (goesFirst c (par a b)))

-- distribute fmap assoc on RHS, too lazy to do it here

matchmake on who goes first:

1: goesFirst a (par b c) == fmap assoc (goesFirst (goesFirst a b) c)
    First:  a = Pure x, b = Op (g k), c = (Op h k)
	goesFirst (Pure x) (par b c) == fmap assoc (goesFirst (goesFirst (Pure x) b) c)
	fmap (x,) (par b c) == fmap assoc (goesFirst (fmap (x,) (Op (g k))) c)
	fmap (x,) (par b c) == fmap assoc (Op (g (par (fmap (x,) k) c)))
    Second: a = Op (f k)
	goesFirst (Op (f k)) (par b c) == fmap assoc (goesFirst (goesFirst (Op (f k)) b) c)
	Op (f (par k (par b c))) == fmap assoc (goesFirst (Op (f (par k b))) c)
	Op (f (par k (par b c))) == fmap assoc (Op (f (par (par k b) c)))
	Call recursively based on whether k is Op or Pure 
2: fmap swap (goesFirst (goesFirst b c) a) == fmap assoc (goesFirst (fmap swap (goesFirst b a)) c)
3: fmap swap (goestFirst (fmap swap (goesFirst c b)) a) == fmap assoc (fmap swap (goesFirst c (par a b)))

-------------------
par :: Choose <: f => Free f a -> Free f b -> Free f (a, b)
par program1 program2 = do
  goesFirst program1 program2 ~+~ fmap swap (goesFirst program2 program1)

goesFirst :: Choose <: f => Free f a -> Free f b -> Free f (a, b)
goesFirst (Pure x) y = fmap (x,) y
goesFirst (Op f) y = Op (fmap (`par` y) f)

