 commutativity === par m1 m2 == fmap swap (par m2 m1)
                  -- par m1 m2 == fmap swap (goesFirst m2 m1 ~+~ goesSecond m2 m1)
                  -- goesFirst m1 m2 ~+~ goesSecond m1 m2 == fmap swap (goesFirst m2 m1 ~+~ goesSecond m2 m1)
                  -- (Op (Choose (\k -> if k then (goesFirst m1 m2) else (goesSecond m1 m2)))) == fmap swap (Op (Choose (\k -> if k then (goesFirst m2 m1) else (goesSecond m2 m1))))

{
base case: m1 = Pure x and m2 = Pure y

 (Op (Choose (\k -> if k then (goesFirst (Pure x) (Pure y)) else (goesSecond (Pure x) (Pure y))))) == fmap swap (Op (Choose (\k -> if k then (goesFirst (Pure y) (Pure x)) else (goesSecond (Pure y) (Pure x)))))
 -- Expand the goesFirst's and goesSecond's
 (Op (Choose (\k -> if k then (fmap (x,) (Pure y)) else (fmap (,y) (Pure x))))) == fmap swap (Op (Choose (\k -> if k then (fmap (y,) (Pure x)) else (fmap (,x) (Pure y)))))
 (Op (Choose (\k -> if k then (Pure (x,y)) else (Pure (x, y))))) == fmap swap (Op (Choose (\k -> if k then (Pure (y,x)) else (Pure (y,x)))))

 use lemma a:
 (Op (Choose (\k -> if k then (Pure (x,y)) else (Pure (x, y))))) == (Op (Choose (\k -> if k then fmap swap (Pure (y,x)) else fmap swap (Pure (y,x)))))
 (Op (Choose (\k -> if k then (Pure (x,y)) else (Pure (x, y))))) == (Op (Choose (\k -> if k then (Pure (swap (y,x))) else (Pure (swap (y,x))))))
 (Op (Choose (\k -> if k then (Pure (x,y)) else (Pure (x, y))))) == (Op (Choose (\k -> if k then (Pure (x,y)) else (Pure (x,y)))))
 which concludes our base case
}
{
 intermediary case: m1 = Pure x, m2 = Op (g k)

 (Op (Choose (\k -> if k then (goesFirst (Pure x) (Op (g k))) else (goesSecond (Pure x) (Op (g k)))))) == fmap swap (Op (Choose (\k -> if k then (goesFirst (Op (g k)) (Pure x)) else (goesSecond (Op (g k)) (Pure x)))))
 (Op (Choose (\k -> if k then (fmap (x,) (Op (g k))) else (Op (fmap (par (Pure x)) (g k)))))) == fmap swap (Op (Choose (\k -> if k then (Op (fmap (`par` (Pure x)) (g k))) else (fmap (,x) (Op (g k))))))

 using lemma a:
 (Op (Choose (\k -> if k then (fmap (x,) (Op (g k))) else (Op (fmap (par (Pure x)) (g k)))))) == (Op (Choose (\k -> if k then fmap swap (Op (fmap (`par` (Pure x)) (g k))) else fmap swap (fmap (,x) (Op (g k))))))

 using lemma a3
 (Op (Choose (\k -> if k then (fmap (x,) (Op (g k))) else (Op (fmap (par (Pure x)) (g k)))))) == (Op (Choose (\k -> if k then (Op (fmap ((fmap swap) . (`par` (Pure x))) (g k))) else fmap swap (fmap (,x) (Op (g k))))))

 (Op (Choose (\k -> if k then (fmap (x,) (Op (g k))) else (Op (fmap (par (Pure x)) (g k)))))) == (Op (Choose (\k -> if k then (Op (fmap ((fmap swap) . (`par` (Pure x))) (g k))) else (fmap (swap . (,x)) (Op (g k))))))
 (Op (Choose (\k -> if k then (fmap (x,) (Op (g k))) else (Op (fmap (par (Pure x)) (g k)))))) == (Op (Choose (\k -> if k then (Op (fmap ((fmap swap) . (`par` (Pure x))) (g k))) else (fmap (x,) (Op (g k))))))

 using lemma d:
 (Op (Choose (\k -> if k then (fmap (x,) (Op (g k))) else (Op (fmap (par (Pure x)) (g k)))))) == (Op (Choose (\k -> if k then (fmap (x,) (Op (g k))) else (Op (fmap ((fmap swap) . (`par` (Pure x))) (g k))))))

so here:
 (Op (Choose (\k -> if k then (fmap (x,) (Op (g k))) else (first_prop)))) == (Op (Choose (\k -> if k then (fmap (x,) (Op (g k))) else (second_prop))))
 which is equal if first_prop == second prop, which is:
 Op (fmap (par (Pure x)) (g k)) == Op (fmap ((fmap swap) . (`par` (Pure x))) (g k))
 g (par (Pure x) k) == g (fmap swap (par k (Pure x)))
 par (Pure x) k == fmap swap (par k (Pure x))

which we can recursively call until our base case.
}
{
second intermediary case
intermediary case: m1 = Op (f k), m2 = Pure y
 (Op (Choose (\k -> if k then (goesFirst (Op (f k)) (Pure y)) else (goesSecond (Op (f k)) (Pure y))))) == fmap swap (Op (Choose (\k -> if k then (goesFirst (Pure y) (Op (f k))) else (goesSecond (Pure y) (Op (f k))))))
 
 using lemma a, a3, and d (similar as in previous case)
 (Op (Choose (\k -> if k then Op (fmap (`par` (Pure y)) (g k)) else (fmap (,y) (Op (f k)))))) == (Op (Choose (\k -> if k then (Op (fmap ((fmap swap) . (par (Pure y))) (f k))) else (fmap (,y) (Op f k)))))

 so here:
 (Op (Choose (\k -> if k then (first_prop) else (fmap (,y) (Op (f k)))))) == (Op (Choose (\k -> if k then (second_prop) else (fmap (,y) (Op f k)))))
 which is equal if first_prop == second prop, which is:
 Op (fmap (`par` (Pure y)) (f k)) == Op (fmap ((fmap swap) . (par (Pure y))) (f k))
 f (par  k (Pure y) ) == f (fmap swap (par k (Pure y)))
 par  k (Pure y) == fmap swap (par k (Pure y))

 which we can recursively call until our base case.

}
{
recursive case: m1 = Op (f k), m2 = Op (g k)

 (Op (Choose (\k -> if k then (goesFirst (Op (f k)) (Op (g k))) else (goesSecond (Op (f k)) (Op (g k)))))) == fmap swap (Op (Choose (\k -> if k then (goesFirst (Op (g k)) (Op (f k))) else (goesSecond (Op (g k)) (Op (f k))))))

 using lemma a, a4, and d:
 (Op (Choose (\k -> if k then Op (fmap (`par` (Op (f k))) (g k)) else (Op (fmap (par (Op (g k))) (Op f k)))))) == (Op (Choose (\k -> if k then (Op (fmap ((fmap swap) . (par (Op (f k))) (g k)))) else (Op (fmap ((fmap swap) . (`par` (Op (g k)))) (f k))))))

 which is equal if
   Op (fmap (`par` (Op (f k))) (g k)) == (Op (fmap ((fmap swap) . (par (Op (f k))) (g k))))
   fmap (`par` (Op (f k))) (g k) == (fmap ((fmap swap) . (par (Op (f k))) (g k)))
   g (par k (Op (f k))) == g (fmap swap (par (Op (f k)) k))
   par k (Op (f k)) == fmap swap (par (Op (f k)) k)
   which can be recursively call until reaching one of the intermediary step.
 and
   (Op (fmap (par (Op (g k))) (Op f k))) == (Op (fmap ((fmap swap) . (`par` (Op (g k)))) (f k)))
   fmap (par (Op (g k))) (Op f k) == fmap ((fmap swap) . (`par` (Op (g k)))) (f k)
   f (par (Op g k) k) == f (fmap swap (par k (Op g k)))
   par (Op g k) k == fmap swap (par k (Op g k))
   which can be recursively call until reaching one of the intermediary step.
}
