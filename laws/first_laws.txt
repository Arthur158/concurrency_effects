
rule M: m1 || m2 == (m1 |L m2) + (m2 |L m1)
rule LM1 (ish; the rule is a little different): pure x |L m == fmap (\y -> (x,y)) m
rule LM2: zero |L m == zero
rule LM3: op (fmap k x) |L m == op (fmap (\x -> (k x) || m) x)
m1 || m2 == fmap swap (m2 || m1)
m1 || (m2 || m3) == fmap assoc ((m1 || m2) || m3)

 m1 || m2 == par m1 m2
 m1 |L m2 == goesFirst m1 m2 or goesSecond m2 m1 depending on the context 
 (depends on whether m1 or m2 is supposed to end up as the first result in the tuple)
 '+' is denoting the nondeterministic branching into different possible results. So it is equivalent to ~+~

 so rule M === par m1 m2 == goesFirst m1 m2 ~+~ goesSecond m1 m2, which is literally its definition (1 step unfolding)

 rule LM1 === goesFirst (pure x) m = fmap (x,) m, which is also just a one step unfolding

 rule LM2 === goesFirst zero m == zero
              goesFirst (Op Zero) m == zero
              Op (fmap (`par` m) Zero) == zero
              Op Zero == zero

 rule LM3 === goesFirst (Op (fmap k x)) m == Op (fmap (\x -> par (k x) m) x)
              Op (fmap (`par` m) (fmap k x)) == Op (fmap (\x -> par (k x) m) x)
              Op (fmap (\x -> par x m) (fmap k x)) == Op (fmap (\x -> par (k x) m) x)
              Op (fmap ((\x -> par x m) . k) x) == Op (fmap (\x -> par (k x) m) x)
              Op (fmap (\x -> par (k x) m) x) == Op (fmap (\x -> par (k x) m) x)

 rule LM4 === goesFirst (x ~+~ y) z == goesFirst x z ~+~ goesFirst y z
              apply lemma d1 with function `goesFirst` z

 rule LM5 === goesFirst xs y == map (`goesFirst` y) xs
      where xs is a list of processes
      Not really applicable in our case, as we don't work with lists of processes like this

 S1 -> S8 : concerns simultaneity, which does not concern us

 TC1 === goesFirst (goesFirst x y) z == goesFirst x (par y z)
        Remember importance to explain role of pure as a nonoperation. Pure represents the end of the calculation,
        so for example goesFirst x y if x = Pure a is simply y (with the result of x in it let's say)
        and goesFirst is never supposed to be faced with a Pure, as it should be handled by par first.
        so only consider case where x = (Op (f k)), y = (Op ())
